{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":"<p>The book of notes I wish I had when starting out with Java. Three resources:</p> <ul> <li>Use the official API docs</li> <li>Use a Java 8 Book</li> <li>Java 8 distribution of choice</li> </ul>"},{"location":"#deploying-locally","title":"Deploying locally","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"#you-can-even-do-mathematics","title":"You can even do mathematics","text":"\\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\]"},{"location":"Collections/ArrayList/","title":"ArrayLists","text":"<p>Declaring an ArrayList. Use non-primitive type in the declaration, i.e. wrapper classes, this is typical of Template Classes, valid for the other Collections as well. If you need to remove items from the middle of the start of a list, or anywhere rather than the absolute end, you'd need to use a LinkedList.</p> <pre><code>List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();\n</code></pre>"},{"location":"Collections/ArrayList/#import-statements","title":"Import statements","text":"<p>To Import the following collections:</p> <pre><code>import java.util.ArrayList;\nimport java.util.List;\n</code></pre>"},{"location":"Collections/ArrayList/#basic-operations-adding","title":"Basic Operations (adding ..)","text":"<pre><code>// Adding\narrayList.add(3);\narrayList.add(45);\narrayList.add(929);\n\n// Retrieving: Specify the Index\narrayList.get(0); // Index 0\n\n// Removing: Specify the Index // Be Careful\narrayList.remove(numbers.size() - 1);\n</code></pre>"},{"location":"Collections/ArrayList/#cycling-through-the-elements-of-an-arraylist","title":"Cycling through the elements of an ArrayList","text":"<p>We can iterate over a set using a certain kind of loops:</p> <pre><code>// Indexed for-loop iteration\nfor(int i = 0; i &lt; arrayList.size(); i++){\n  // Printing all the elements as console output\n  System.out.println(arrayList.get(i));\n}\n\n// Iteration \nfor(Integer value: arrayList){\n  // \n  int value = (int) arrayList.get(value);\n  System.out.println(value);\n}\n</code></pre> <p>Note that:</p> <pre><code>map.keySet();\n</code></pre> <p>returns a Collection called \"Set\", which is itself a data structure.</p>"},{"location":"Collections/ArrayList/#passing-an-arraylist-object-to-a-method-list-interface","title":"Passing an ArrayList Object to a method (List&lt;&gt; Interface)","text":"<p>This is how you pass a map to a method. Notice how it is possible to pass the interface's type List&lt;&gt; to the method</p> <pre><code>public static void Main(String[] args){\n\n  List&lt;Integer&gt; arrayList = new ArrayList&lt;Integer&gt;();\n  testArrayList(arrayList);\n}\n\npublic static void testArrayList(ArrayList&lt;Integer&gt; arrayList){\n\n // Operations\n // arrayList.get(key);\n}\n</code></pre>"},{"location":"Collections/ArrayList/#natural-order","title":"Natural Order","text":"<p>For strings natural order is alphabetical order, for numbers is the ordinal sorting. You can define a natural order of your classes.</p> <pre><code>Collections.sort(myList);\n</code></pre>"},{"location":"Collections/Collections/","title":"Which Java Collection to choose for which purpose","text":""},{"location":"Collections/Collections/#lists","title":"Lists","text":"<ul> <li>Store Lists of Objects</li> <li>Duplicates are allowed</li> <li>Objects remain in order</li> <li>Elements are indexed via an integer</li> <li>Checking for a particular item in list is slow</li> <li>Looking an item up by index is fast</li> <li>Iterating through lists is relatively fast</li> <li>Note: you can sort lists if you want to</li> </ul> <pre><code>// If you only add or remove items at end of the list, use ArrayList\nList&lt;String&gt; list1 = new ArrayList&lt;String&gt;();\n</code></pre> <pre><code>// Removing or adding items elsewhere in the list\nList&lt;String&gt; list2 = new LinkedList&lt;String&gt;();\n</code></pre>"},{"location":"Collections/Collections/#sets","title":"Sets","text":"<ul> <li>Only store unique values</li> <li>Great for removing duplicates</li> <li>Not Indexed, unlike lists, so there's no particular position, no positioning</li> <li>Very fast to check if a particular object exists</li> <li>If you want to use your own objects, you must implement hashCode() and equals()</li> <li>You decide whether objects are the same of not by implementing hashCode() and equals()</li> </ul> <pre><code>// Order is not important and it might change: HashSet\nSet&lt;String&gt; set1 = new HashSet&lt;String&gt;();\n</code></pre> <pre><code>// Sorted in Natural Order (alphabetical, numerical ascending order), must implement Comparable for custom types\nSet&lt;String&gt; set2 = new TreeSet&lt;String&gt;();\n</code></pre> <pre><code>// Elements remain in the order they were added\nSet&lt;String&gt; set3 = new LinkedHashSet&lt;String&gt;();\n</code></pre>"},{"location":"Collections/Collections/#maps","title":"Maps","text":"<ul> <li>Key-value pairs (i.e. <code>&lt;String, Integer&gt;</code>, <code>&lt;String, Integer, Double, String&gt;</code>, ...)</li> <li>Retrieving a value by key is fast</li> <li>Iterating over maps is slow</li> <li>Maps are not optimised for iteration (if doing so, iterate through the keys)</li> <li>If you want to use your own objects as keys, you must implement hashCode() and equals()</li> </ul> <pre><code>// Keys not in any particular order, and order liable to change\nMap&lt;String, String&gt; map1 = new HashMap&lt;String, String&gt;();\n</code></pre> <pre><code>// Keys sorted in natural Order (alphabetical, numerical ascending order)\nMap&lt;String, String&gt; map2 = new TreeMap&lt;String, String&gt;();\n</code></pre> <pre><code>// Keys remain in order added\nMap&lt;String, String&gt; map3 = new LinkedHashMap&lt;String, String&gt;();\n</code></pre> <pre><code>computeIfAbsent( key, mappingFunction);\n// if key exists, return it's value.\n// if key doesn't exist, use the mappingFunction to calculate value.\n\n// examples:\nreturn map.computeIfAbsent(key, k -&gt; computeValue(k)); \nmap.computeIfAbsent(\"fruits\", k -&gt; new ArrayList&lt;&gt;()).add(\"apple\");\n// \u67e5\u627e\"fruits\"\u952e\u662f\u5426\u5b58\u5728\uff0c\u82e5\u662f\u5b58\u5728\u8fd4\u56de\u5bf9\u5e94\u7684\u503c\uff0c\u82e5\u4e0d\u5b58\u5728\uff0c\u5219\u521b\u5efa\u4e00\u4e2aarraylist\u5e76\u628aapple\u4f5c\u4e3a\u5bf9\u5e94\u7684\u503c\u3002\n</code></pre>"},{"location":"Collections/Collections/#the-collection-root-interface","title":"The <code>Collection</code> Root Interface","text":"<pre><code>// A root interface more flexible (for example can change from Map to Set), \n// so if we wanna in a common use, just Collection ia enough.\n\nCollection&lt;Customer&gt; customers = new ArrayList&lt;&gt;();\n\n// Since it's a root interface, we can use the same way as List, Map to access, remove etc.\ncustomers.add(s);\n</code></pre> <pre><code>//  method 'clear()' is defined in java.util.Collection interface\n//  Remove all the elements in List/Set/Queue/Map(remove both Key and Value)\n\n//  Example in lab3 WorkingHours.java\n\n    workingHours.clear();\n//  Remove first, make sure add brand new time period after.\n\n</code></pre>"},{"location":"Collections/Collections/#the-return-value-of-collection-method","title":"The return value of Collection method","text":"<pre><code>public Collection&lt;String&gt; restaurants() {\n        return new LinkedList&lt;&gt;(restaurants.keySet());\n}\n    // keySet() is a method of Map Interface\uff0creturn all the Key's view of Set&lt;String&gt;\n\n    // These codes means: \n    // Transfer all the Key of 'restaurants' into a Set, and then use this Set create a new LinkedList.\n\n</code></pre>"},{"location":"Collections/HashMap/","title":"Hash Map","text":"<p>Maps store pair values where one member is called the \"key\" and the other one is called the \"value\". The HashMap does not maintain order, hence, for this purpose there's the need for SortedMaps.</p> <pre><code>HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;Integer, String&gt;();\n</code></pre> <pre><code>LinkedHashMap&lt;Integer, String&gt; linkedhashMap = new LinkedHashMap&lt;Integer, String&gt;();\n</code></pre> <pre><code>TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;Integer, String&gt;();\n</code></pre>"},{"location":"Collections/HashMap/#import-statements","title":"Import statements","text":"<p>To Import the following collections:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.LinkedHashMap;\nimport java.util.TreeMap;\n</code></pre>"},{"location":"Collections/HashMap/#populating-retrieving-and-other-operations","title":"Populating, retrieving and other operations","text":"<p>The put method is what populates the map</p> <pre><code>map.put(5, \"Five\"); // 5 is a primitive type, but Java autoboxes with the respective wrapper class\n</code></pre> <p>The get method is used to retrieve values off the Map</p> <pre><code>map.get(0); // I pass the index to the get method\n</code></pre>"},{"location":"Collections/HashMap/#passing-a-map-object-to-a-method","title":"Passing a Map Object to a method","text":"<p>This is how you pass a map to a method. Notice how it is possible to pass the interface's type Map&lt;&gt; to the method</p> <pre><code>public static void Main(String[] args){\n\n  TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;Integer, String&gt;();\n  testMap(treeMap);\n}\n\npublic static void testMap(Map&lt;Integer, String&gt; map){\n\n // Operations\n // map.get(key);\n}\n</code></pre>"},{"location":"Collections/HashMap/#iterating-through-the-map","title":"Iterating through the Map","text":"<p>We can iterate over a set using a foreach loop.</p> <pre><code>Map.Entry&lt;Integer, String&gt;\n</code></pre> <pre><code>for(Map.Entry&lt;Integer, String&gt; entry: map.entrySet()){\n  // Returns the value corresponding to that key\n  String value = map.get(key);\n}\n</code></pre> <pre><code>for(Integer key: map.keySet()){\n  // Returns the value corresponding to that key\n  String value = map.get(key);\n}\n</code></pre> <p>Note that:</p> <pre><code>map.keySet();\n</code></pre> <p>returns a Collection called \"Set\", which is itself a data structure.</p>"},{"location":"Collections/HashMap/#natural-order","title":"Natural Order","text":"<p>For strings natural order is alphabetical order, for numbers is the ordinal sorting. You can define a natural order of your classes.</p>"},{"location":"Collections/LinkedList/","title":"LinkedList and the List Interface","text":"<p>Declaring a LinkedList. Use non-primitive type in the declaration, i.e. wrapper classes, this is typical of Template Classes, valid for the other Collections as well. If you need to remove items from the middle of the start of a list, or anywhere rather than the absolute end, you'd need to use a LinkedList.</p> <pre><code>List&lt;Integer&gt; linkedList = new LinkedList&lt;Integer&gt;();\n</code></pre>"},{"location":"Collections/LinkedList/#import-statements","title":"Import statements","text":"<p>To Import the following collections:</p> <pre><code>import java.util.LinkedList;\nimport java.util.List;\n</code></pre>"},{"location":"Collections/SortedMaps/","title":"Sorted Maps and the Map Interface - Java Collections Framework","text":"<p>There are different implementation of the Map Interface. The first element is identified as the \"key\" of the data structure.</p> <pre><code>HashMap&lt;Integer, String&gt; hashMap = new HashMap&lt;Integer, String&gt;();\n</code></pre> <pre><code>LinkedHashMap&lt;Integer, String&gt; LhashMap = new LinkedHashMap&lt;Integer, String&gt;();\n</code></pre> <pre><code>TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;Integer, String&gt;();\n</code></pre>"},{"location":"Collections/SortedMaps/#import-statements","title":"Import statements","text":"<p>To Import the following collections:</p> <pre><code>import java.util.HashMap;\nimport java.util.Map;\nimport java.util.LinkedHashMap;\nimport java.util.TreeMap;\n</code></pre>"},{"location":"Collections/SortedMaps/#passing-a-map-object-to-a-method","title":"Passing a Map Object to a method","text":"<p>This is how you pass a map to a method. Notice how it is possible to pass the interface's type Map&lt;&gt; to the method</p> <pre><code>public static void Main(String[] args){\n\n  TreeMap&lt;Integer, String&gt; treeMap = new TreeMap&lt;Integer, String&gt;();\n  testMap(treeMap);\n}\n\npublic static void testMap(Map&lt;Integer, String&gt; map){\n\n // Operations\n // map.get(key);\n}\n</code></pre>"},{"location":"Collections/SortedMaps/#cycling-through-the-elements-of-a-sortedmap","title":"Cycling through the elements of a SortedMap","text":"<p>We can iterate over a set using a certain kind of loops:</p> <pre><code>for(Integer key: map.keySet()){\n  // Returns the value corresponding to that key\n  String value = map.get(key);\n}\n</code></pre> <p>Note that:</p> <pre><code>map.keySet();\n</code></pre> <p>returns a Collection called \"Set\", which is itself a data structure.</p>"},{"location":"Collections/SortedMaps/#natural-order","title":"Natural Order","text":"<p>For strings natural order is alphabetical order, for numbers is the ordinal sorting. You can define a natural order of your classes.</p>"},{"location":"IO/IO/","title":"Basic I/O for Java","text":""},{"location":"IO/IO/#inputoutput-on-the-console","title":"Input/Output on the console","text":""},{"location":"IO/IO/#scan","title":"Scan","text":"<p>Just read an Int with Scan</p> <pre><code>System.out.println(\"n partecipants: \");\nScanner scan = new Scanner(System.in);\nint n = scan.nextInt();\n</code></pre> <p>Read an entire input and then collect the values with \"split\"</p> <pre><code>Scanner scanner = new Scanner(System.in);\nString input = scanner.next();\nint words[] = input.split(' ');\n</code></pre>"},{"location":"IO/IO/#buffered-reader","title":"Buffered Reader","text":"<pre><code>BufferedReader in = new BufferedReader(new InputStreamReader(System.in)); \nString[] input = new String[2];     \ninput = in.readLine().split(\" \"); \nint a; \nint b; \na = Integer.parseInt(input[0]); \nb = Integer.parseInt(input[1]); \nSystem.out.println(\"You input: \" + a + \" and \" + b); \n</code></pre>"},{"location":"IO/Read-Files/","title":"Reading a File in Java","text":"<p>We have three classes for reading from a Java file:</p> <ul> <li>Scanner</li> <li>FileReader</li> <li>BufferedReader</li> </ul> <p>We also have a class called File that allows us to instantiate a File Object, which is the File representation in Java.</p>"},{"location":"IO/Read-Files/#reaching-the-file-in-the-file-system","title":"Reaching the file in the File System","text":"<p>In Eclipse, the root of the project folder is where the file system search starts at.</p> <p>If Somewhere in the file system, on Windows</p> <pre><code>String fileName = \"C:\\\\users\\\\username\\\\Desktop\\\\folder\\\\file.csv\"\n</code></pre> <p>If in the src/ directory, inside the project folder, in Eclipse</p> <pre><code>String fileName = \"src\\\\file.csv\"\n</code></pre> <p>If in the root of the project folder, in Eclipse</p> <pre><code>String fileName = \"file.csv\"\n</code></pre>"},{"location":"IO/Read-Files/#reading-files-with-the-scanner-class","title":"Reading Files with the Scanner class","text":"<p>Let's create a File Object, which will be a Java representation of your file.</p> <pre><code>File textFile = new File(fileName);\n</code></pre> <p>Reading file using the Scanner class, I pass the file Object I want to read</p> <pre><code>Scanner in = new Scanner(textFile);\n\n// Reading the first integer of the file, supposing the first thing to read\n// is a number\nin.nextInt();\n\n// Reading the new line character after the first one\nin.nextLine();\n\n// Reading it line by line\nwhile(in.hasNextLine()){\n  String line = in.nextLine();\n  // Operations with the line\n}\n\n// Closing the file\nin.close();\n</code></pre>"},{"location":"IO/Read-Files/#reading-files-with-the-filereader-class","title":"Reading files with the FileReader class","text":"<pre><code>import java.io.*;\n</code></pre> <pre><code>File file = new File(\"text.txt\");\n</code></pre>"},{"location":"IO/Read-Files/#reading-a-csv-file-with-the-bufferedreader-class","title":"Reading a CSV File with the BufferedReader class","text":"<p>Importing the necessary libraries</p> <pre><code>import java.io.*;\n</code></pre> <p>The location of the File in an Eclipse Project Folder</p> <pre><code>String file = \"src\\\\students.csv\";\n</code></pre> <p>Instantiating the BufferedReader class as \"null\", for now</p> <pre><code>BufferedReader reader = null;\n</code></pre> <p>Will be using the following to read each line of our file</p> <pre><code>String line = \"\";\n</code></pre> <p>Let's create a Try/Catch/Finally block to manage the eventual errors. Note: Eclipse will probably suggest its own way to managing error through try and catch blocks. Better using the following.</p> <pre><code>try{\n  // Finishing instantiating our Reader\n  // Withing the parentheses we pass an anonymous FileReader\n  reader = new BufferedReader(new FileReader(file));\n  // This while loop is going to continuosly read the next line\n  // and checking if it is not \"null\"\n  while((line = reader.readLine()) != null){\n\n    // We specify our character, that's a String, where we want to split our line at.\n    // Then, after taking all of the values of this very row in this CSV, we assing them\n    // to an array of type String.\n    String[] row = line.split(\",\");\n\n    // Printing them on console ( yet to write )\n    for(String index: row){\n      System.out.println();\n    }\n\n  }\n} \n// Let's catch all exceptions, since there's a moltitude of exceptions that\n// could be catched, such as FileNotFoundException or IOException\ncatch(Exception e)\n{\n  // If something goes wrong, this prints the Stack Trace\n  e.printStackTrace();\n}\nfinally{\n\n  // In programs were Scanner and BufferedReader are opened, it's good\n  // practice to close them in the end. Also, it's good practice to surround them\n  // with try and catch blocks.\n\n  try{\n    reader.close();\n  }catch(IOException e){\n    e.printStackTrace();\n  }\n}\n</code></pre>"},{"location":"Maven/Intro/","title":"Maven","text":"<p>Maven is a build automation and project management tool for Java (and other JVM)  projects. It resolves dependencies, downloads them, compiles your code, runs tests,  packages artifacts, and even deploys them to repositories. You simply list the  libraries you need (e.g. JUnit) in your POM, then, it looks in your local cache  (usually ~/.m2/repository); if it\u2019s not there, it downloads them from remote  repositories (by default Maven Central) and caches them for you</p>"},{"location":"Maven/Intro/#the-configuration-file-pomxml","title":"The configuration file: <code>pom.xml</code>","text":"<p>Describes your project in a POM (Project Object Model). You can create a \u201cparent\u201d POM that aggregates several sub-modules, which means that supports multi-module projects.</p> <p>A pom.xml file sits at the root of your project.</p>"},{"location":"Maven/Intro/#maven-project-structure","title":"Maven project structure","text":"<p>Using a standard directory layout (src/main/java, src/test/java, etc.) means you rarely have to configure where your code lives.</p> <p>Maven expects:</p> <pre><code>src/\n  \u2514\u2500\u2500 main/\n      \u2514\u2500\u2500 java/\n            \u2514\u2500\u2500 Package1/\n  \u2514\u2500\u2500 test/\n      \u2514\u2500\u2500 java/\n            \u2514\u2500\u2500 TestSuite1/\n</code></pre> <p>If you want you can omit the <code>src/test</code> repository, and just go with <code>src/main</code>.  But, on <code>src/main</code>, I'd suggest to put a <code>Main.java</code> within the package:</p> <pre><code>&lt;configuration&gt;\n    &lt;!-- Fully qualified name of your entry point --&gt;\n    &lt;mainClass&gt;Package1.Main&lt;/mainClass&gt;\n&lt;/configuration&gt;\n</code></pre> <p>and, on top of the <code>Main.java</code> file:</p> <pre><code>package Package1;\n</code></pre> <p>having this in the <code>pom.xml</code> ensures the fact that you've got yourself an entrypoint, a <code>Main</code>, to your application.</p>"},{"location":"Maven/Intro/#maven-goals","title":"Maven goals","text":"<p>After setting up the project structure, you can run Maven goals like <code>mvn clean</code>, <code>mvn compile</code>, <code>mvn test</code>, <code>mvn package</code>, <code>mvn install</code>.</p>"},{"location":"OOP/FactoryMethod/","title":"Factory Method","text":"<p>Encapsulating the object creation process.</p> <p>Makes the code more flexible, extensible, and easy to maintain.</p> <p>Processing a \"new\" objects to a method instead of using \"new\" directly in the code.</p>"},{"location":"OOP/FactoryMethod/#difference-from-interface","title":"Difference from Interface","text":"<p>Interface:</p> <pre><code>    public interface Animal {\n        void makeSound();\n    }\n\n    // in class\n    public class Dog implements Animal {\n        public void makeSound() {\n            System.out.println(\"Woof!\");\n        }\n    }\n\n    public class Cat implements Animal {\n        public void makeSound() {\n            System.out.println(\"Meow!\");\n        }\n    }\n</code></pre> <p>Factory Method:</p> <pre><code>public class AnimalFactory {\n\n    public static Animal createAnimal(String type) {\n        if (type.equalsIgnoreCase(\"dog\")) {\n            return new Dog(); // \u8fd4\u56de\u7684\u662f\u5b9e\u73b0\u4e86 Animal \u63a5\u53e3\u7684\u7c7b\n        } else if (type.equalsIgnoreCase(\"cat\")) {\n            return new Cat();\n        } else {\n            throw new IllegalArgumentException(\"Unknown animal type\");\n        }\n    }\n}\n\nAnimal a = AnimalFactory.createAnimal(\"dog\");\na.makeSound();      // output: \"Woof!\"\n\n</code></pre> <p>\u63a5\u53e3\uff1a\u5b9a\u4e49\u4e86\u201c\u80fd\u505a\u4ec0\u4e48\u201d\uff08\u884c\u4e3a\u89c4\u8303\uff09\u3002</p> <p>\u5de5\u5382\u65b9\u6cd5\uff1a\u5b9a\u4e49\u4e86\u201c\u521b\u5efa\u8c01\u6765\u505a\u201d\uff08\u5177\u4f53\u5b9e\u73b0\u7684\u9009\u62e9\u903b\u8f91\uff09\u3002</p> <p>\u63a5\u53e3\u63cf\u8ff0\u201c\u5e94\u8be5\u6709\u4ec0\u4e48\u201d\uff0c\u800c\u5de5\u5382\u65b9\u6cd5\u51b3\u5b9a\u201c\u5230\u5e95\u8981\u7528\u54ea\u4e00\u4e2a\u7c7b\u6765\u5b9e\u73b0\u8fd9\u4e2a\u63a5\u53e3\u201d\u3002</p> <pre><code>    // Lab 4:\n    public Municipality createOrGetMunicipality(String name, String province, Integer altitude) {\n        return municipalities.computeIfAbsent(name, \n            k -&gt; new Municipality(name, province, altitude));\n    }\n\n    public MountainHut createOrGetMountainHut(String name, Arguments...) {\n        return mountainHuts.computeIfAbsent(name, \n                    k -&gt; new MountainHut(name, Arguments...));\n    }\n</code></pre>"},{"location":"OOP/GetterSetter/","title":"getter","text":"<p>Accessing(Getting) private properties of a class from outside.</p>"},{"location":"OOP/GetterSetter/#setter","title":"setter","text":"<p>Modifying(Setting) private properties of a class from outside.</p>"},{"location":"OOP/Interfaces/","title":"Interfaces in Java","text":"<pre><code>// If a class implements an Interface, then all the abstract method in this Interface defined must be implemented. Otherwise compiler report bugs. \n\n/*\ncompareTo(T other): Returns:\n\nNegative integer if the current object is \"less than\" other.\nZero if the current object is \"equal to\" other.\nPositive integer if the current object is \"greater than\" other.\n*/\n\nExample: \npublic class Restaurant implements Comparable&lt;Restaurant&gt; {\n\n    @Override\n    public int compareTo(Restaurant o) {\n        return this.getName().compareTo(o.getName());\n    }\n\n}\n</code></pre>"},{"location":"OOP/Object-Search/","title":"Searching an object","text":""},{"location":"OOP/Package-Java.lang-method/","title":"About method in java.lang","text":"<p>Automatically available package.</p>"},{"location":"OOP/Package-Java.lang-method/#1-split","title":"1 split","text":"<pre><code>/* The split method belongs to the String class, which is part of the java.lang package. This package is automatically imported in all Java programs\n*/\n\n// How to use: Splits a String into an array of substrings using \":\" as the delimiter.\n\n String[] hm = time.split(\":\");\n//  \"10:30\" \u2192 [\"10\", \"30\"] \n// Example from lab3 Time.java\n</code></pre>"},{"location":"OOP/Package-Java.lang-method/#2-parseint","title":"2 parseInt","text":"<pre><code>//   Converts a String to an int.\n\n    h = Integer.parseInt(hm[0]);\n\n// Transfer first element of String 'hm' to an integer. \n\n</code></pre>"},{"location":"OOP/Package-Java.lang-method/#trim","title":"trim()","text":"<p>Removes all space characters from the beginning and end of a string.</p> <pre><code>    String province = fields[0].trim();  \n</code></pre>"},{"location":"OOP/Polymorphism/","title":"Object class","text":"<p>By polymorphism, we can see any instance of any class as an Object instance. Object is the universal reference type.</p>"},{"location":"OOP/enum/","title":"enum in Java","text":"<pre><code>//   Using pre-defined enum value only, protect code from illegal input. In java, it can contains method or interface.\n\n//Example 1: \n    public enum OrderStatus{\n        ORDERD,\n        READY,\n        DELIEVED;\n    }\n\n    Order order = new Order();\n\n    order.setStatus(OrderStatus.READY);\n    //  enum value accepted only  \u2191 \n\n// Example 2:\n    public enum PaymentMethod {\n    CASH(\"\u73b0\u91d1\", 0),      // Cash, 0% of Service charge. \n    CARD(\"\u4fe1\u7528\u5361\", 1.5),   // Credit card, 1.5%\n    PAYPAL(\"\u8d1d\u5b9d\", 2.0);   // Online, 2.0%\n\n // Counting Service charge:\n    double amount = 1000.0;\n    double fee = PaymentMethod.CARD.calculateFee(amount);\n\n</code></pre>"},{"location":"PackageSystem/packages/","title":"Java's package system","text":""},{"location":"Streams/Streams/","title":"Streams (Java8)","text":"<p>Motivation:</p> <p>Streams are Monads, thus playing a big part in bringing functional programming to Java: In functional programming, a monad is a structure that represents computations defined as sequences of steps. A type with a monad structure defines what it means to chain operations, or nest functions of that type together.</p> <p>quote: this man</p>"},{"location":"Streams/Streams/#lambda-expressions","title":"Lambda Expressions","text":"<p>'.' means: Directly invoking method or access properties. </p> <pre><code>Class.staticMethod()\n```java\n\n'::' means:\nPassing methods as parameters to functional interfaces.\n\u5c06[\u65b9\u6cd5]\u4f5c\u4e3a[\u53c2\u6570]\u4f20\u9012\u7ed9\u51fd\u6570\u5f0f\u63a5\u53e3\nIt is a short form of Lambda.\n\n```java\nstream.map(String::toUpperCase)\n</code></pre>"},{"location":"Streams/Streams/#basic-concepts-of-stream","title":"Basic Concepts of stream","text":"<ol> <li>Source operations: Create: Generate a stream from a data source (collection, array, etc.).</li> </ol> <pre><code>Stream&lt;String&gt; stream = list.stream();\n// or\nStream&lt;String&gt; parallelStream = list.parallelStream(); \n</code></pre> <ol> <li>Intermediate Operations:  Define data processing logic (such as filtering, mapping).</li> </ol> <pre><code>.filter(n -&gt; n % 2 == 0)  // \u4fdd\u7559\u5076\u6570\n.map(String::toUpperCase)  // \u8f6c\u6362\u4e3a\u5927\u5199\n.flatMap(List::stream)  // \u6241\u5e73\u5316\u4e3a\u5355\u4e2a\u6d41\n.distinct()\n.sorted()                   // natural order\n.skip(5)    // \u8df3\u8fc7\u524d5\u4e2a\uff080-4\uff09\n.limit(3)   // \u53d6\u63a5\u4e0b\u6765\u76843\u4e2a\n</code></pre> <ol> <li>Terminal Operations: Trigger the actual calculation and generate results.</li> </ol> <pre><code>.collect(Collectors.toList());      \n.forEach(System.out::println);\n.reduce(0, Integer::sum);\n.findFirst();\n.findAny();\n.max(Integer::compare);\n.count();\n.min();\n</code></pre> <p>To put it simple, see how the following code gets shortened at each step:</p> <p>Step 1</p> <pre><code>List&lt;String&gt; names = Arrays.asList(\"peter\", \"anna\", \"mike\", \"xenia\");\nCollections.sort(names, new Comparator&lt;String&gt;() {\n@Override\npublic int compare(String a, String b) {\nreturn b.compareTo(a);\n}\n});\n</code></pre> <p>Step 2</p> <pre><code>Collections.sort(names, (String a, String b) -&gt; {\nreturn b.compareTo(a);\n});\n</code></pre> <p>Step 3</p> <pre><code>Collections.sort(names, (String a, String b) -&gt; b.compareTo(a));\n</code></pre> <p>Step 4</p> <pre><code>Collections.sort(names, (a, b) -&gt; b.compareTo(a));\n</code></pre>"},{"location":"Streams/Streams/#imports","title":"Imports","text":"<p>example</p> <pre><code>List&lt;String&gt; myList =\nArrays.asList(\"a1\", \"a2\", \"b1\", \"c2\", \"c1\");\n\nmyList\n.stream()                            // 1. Create operation\n.filter(s -&gt; s.startsWith(\"c\"))      // 2. Middle operations\n.map(String::toUpperCase)\n.sorted()\n.forEach(System.out::println);       // 3. Terminal operation\n</code></pre> <p>Some Characteristics:</p> <ol> <li> <p>Non-Reusability A Stream can be consumed only once.</p> </li> <li> <p>Lazy Evaluation (Delayed Execution)  Actual computation happens when a terminal operation (e.g., collect, forEach) is invoked.</p> </li> <li> <p>Parallel Processing Streams can leverage multicore processors via parallel execution.</p> </li> </ol>"}]}